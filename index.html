<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dreamy Gallery - Zoomable</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #fffacd; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #888; font-family: sans-serif; font-size: 20px;
            pointer-events: none;
        }
        #instructions {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #555; font-family: sans-serif; font-size: 16px;
            background: rgba(255, 255, 255, 0.8); padding: 10px 20px; border-radius: 20px;
            pointer-events: none; opacity: 0.8; text-align: center;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading">Enabling Zoom...</div>
    <div id="instructions">
        <b>W A S D</b> to Walk<br>
        <b>Mouse Wheel</b> to Zoom In/Out
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';

        let scene, camera, renderer;
        const animatedObjects = { plants: [], art: [], clouds: [] };
        let player, keys;
        
        // --- ZOOM VARIABLES ---
        let currentZoom = 6; // Default distance
        let targetZoom = 6;  // For smooth interpolation
        const minZoom = 2;   // Closest
        const maxZoom = 12;  // Furthest
        
        init();

        function init() {
            document.getElementById('loading').style.display = 'none';

            // --- 1. SCENE SETUP ---
            scene = new THREE.Scene();
            
            // --- PALETTE ---
            const colBlue = new THREE.Color(0xb0e0e6);   
            const colPink = new THREE.Color(0xffd1dc);   
            const colYellow = new THREE.Color(0xfafac6); 
            const colFog = new THREE.Color(0xfff5e1);    

            scene.fog = new THREE.FogExp2(colFog, 0.012);

            // SKY SHADER
            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `;
            const fragmentShader = `
                uniform vec3 topColor;
                uniform vec3 midColor;
                uniform vec3 botColor;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize( vWorldPosition ).y;
                    vec3 color;
                    if(h < 0.05) {
                         color = mix(botColor, midColor, smoothstep(-0.2, 0.05, h));
                    } else {
                         color = mix(midColor, topColor, smoothstep(0.05, 0.8, h));
                    }
                    gl_FragColor = vec4( color, 1.0 );
                }
            `;
            const skyMat = new THREE.ShaderMaterial({
                vertexShader, fragmentShader,
                uniforms: {
                    topColor: { value: colBlue },
                    midColor: { value: colPink },
                    botColor: { value: colYellow }
                },
                side: THREE.BackSide
            });
            const skySphere = new THREE.Mesh(new THREE.SphereGeometry(800, 32, 15), skyMat);
            scene.add(skySphere);

            // --- RENDERER ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1; 
            renderer.setClearColor(colFog);
            document.body.appendChild(renderer.domElement);
            RectAreaLightUniformsLib.init();

            // --- CAMERA ---
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            // --- INPUT HANDLING ---
            keys = { w: false, a: false, s: false, d: false };
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = true;
                if (e.key === 'ArrowUp') keys.w = true;
                if (e.key === 'ArrowDown') keys.s = true;
                if (e.key === 'ArrowLeft') keys.a = true;
                if (e.key === 'ArrowRight') keys.d = true;
            });
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = false;
                if (e.key === 'ArrowUp') keys.w = false;
                if (e.key === 'ArrowDown') keys.s = false;
                if (e.key === 'ArrowLeft') keys.a = false;
                if (e.key === 'ArrowRight') keys.d = false;
            });

            // --- NEW: MOUSE WHEEL ZOOM LISTENER ---
            window.addEventListener('wheel', (e) => {
                // Determine zoom direction (e.deltaY > 0 is scrolling down/out)
                const zoomSpeed = 0.5;
                if (e.deltaY > 0) {
                    targetZoom += zoomSpeed;
                } else {
                    targetZoom -= zoomSpeed;
                }
                // Clamp the zoom level
                targetZoom = Math.max(minZoom, Math.min(maxZoom, targetZoom));
            });


            // --- 2. LIGHTING ---
            const hemiLight = new THREE.HemisphereLight(colBlue, colYellow, 0.6);
            scene.add(hemiLight);

            const sunLight = new THREE.DirectionalLight(0xffdfba, 1.4); 
            sunLight.position.set(50, 25, -50); 
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(2048, 2048);
            scene.add(sunLight);

            createWindowLight(0, -10);
            createWindowLight(-20, -10);
            createWindowLight(-40, -10);
            createWindowLight(10, 0, Math.PI/2);

            function createWindowLight(x, z, ry=0) {
                const rectLight = new THREE.RectAreaLight(0xffffe0, 2.0, 18, 10);
                rectLight.position.set(x, 5, z);
                rectLight.rotation.y = ry;
                if(ry === 0) rectLight.lookAt(x, 5, z + 10);
                scene.add(rectLight);
            }

            // --- 3. MATERIALS ---
            const mats = {
                wall: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 }), 
                ceiling: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 }), 
                glass: new THREE.MeshPhysicalMaterial({ roughness: 0, transmission: 1, thickness: 0.5, ior: 1.5, transparent: true }),
                floor: new THREE.MeshStandardMaterial({ color: 0xfff8e7, roughness: 0.6 }), 
                mint: new THREE.MeshStandardMaterial({ color: 0xb2e0d6, roughness: 0.3 }),
                blue: new THREE.MeshStandardMaterial({ color: 0xaec6cf, roughness: 0.3 }),
                pedestal: new THREE.MeshStandardMaterial({ color: 0xfffdf0, roughness: 0.5 }),
                canvas: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 }),
                pot: new THREE.MeshStandardMaterial({ color: 0xfff5e6, roughness: 0.8 }),
                leaf: new THREE.MeshStandardMaterial({ color: 0x8fb9aa, roughness: 0.4, side: THREE.DoubleSide }),
                stem: new THREE.MeshStandardMaterial({ color: 0x6faf8f, roughness: 0.6 }),
                cloud: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9, emissive: 0xfff5e1, emissiveIntensity: 0.2 }),
                playerBody: new THREE.MeshStandardMaterial({ color: 0xe6e6fa, roughness: 0.3 }),
                playerEye: new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.1 })
            };

            const geos = {
                pot: new THREE.CylinderGeometry(0.4, 0.35, 0.8, 32),
                stem: new THREE.CylinderGeometry(0.05, 0.04, 2, 8).translate(0, 1, 0),
                leaf: new THREE.CircleGeometry(0.5, 16).scale(0.5, 2.5, 1).translate(0, 1.25, 0),
                cloudGeo: new THREE.SphereGeometry(5, 32, 16),
                box_20_10_1: new THREE.BoxGeometry(20, 10, 1),
                box_1_10_20: new THREE.BoxGeometry(1, 10, 20),
                box_1_10_8: new THREE.BoxGeometry(1, 10, 8)
            };

            // --- 4. BUILD SCENE ---
            buildArchitecture(mats, geos);
            placeArt(mats, geos);
            placePlants(mats, geos);
            createCloudSea(mats, geos); 
            createPlayer(mats);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createPlayer(m) {
            player = new THREE.Group();
            
            const bodyGeo = new THREE.CapsuleGeometry(0.4, 0.8, 4, 8);
            const body = new THREE.Mesh(bodyGeo, m.playerBody);
            body.position.y = 0.8; 
            body.castShadow = true;
            player.add(body);

            const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
            const head = new THREE.Mesh(headGeo, m.playerBody);
            head.position.y = 1.4;
            head.castShadow = true;
            player.add(head);

            const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeL = new THREE.Mesh(eyeGeo, m.playerEye);
            eyeL.position.set(-0.15, 1.45, 0.28);
            player.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, m.playerEye);
            eyeR.position.set(0.15, 1.45, 0.28);
            player.add(eyeR);

            player.position.set(5, 0, 5);
            player.rotation.y = Math.PI / 2; 
            
            scene.add(player);
        }

        function updatePlayerMovement() {
            if(!player) return;

            const moveSpeed = 0.12;
            const rotSpeed = 0.04;

            if (keys.w) player.translateZ(moveSpeed); 
            if (keys.s) player.translateZ(-moveSpeed); 
            if (keys.a) player.rotation.y += rotSpeed; 
            if (keys.d) player.rotation.y -= rotSpeed; 

            // Collision
            if (player.position.z < -8.5) player.position.z = -8.5;
            if (player.position.z > 8.5) player.position.z = 8.5;
            if (player.position.x > 8.5) player.position.x = 8.5;
            if (player.position.x < -58) player.position.x = -58;

            // --- UPDATE ZOOM ---
            // Smoothly interpolate current zoom to target
            currentZoom += (targetZoom - currentZoom) * 0.1;

            // --- CAMERA FOLLOW ---
            // Calculate height offset based on zoom (higher when zoomed out)
            const heightOffset = currentZoom * 0.5;
            // The relative offset is: Up (dynamic) and Behind (dynamic)
            const relativeCameraOffset = new THREE.Vector3(0, heightOffset, -currentZoom);
            
            const cameraOffset = relativeCameraOffset.applyMatrix4(player.matrixWorld);
            camera.position.lerp(cameraOffset, 0.1);
            
            // Look slightly above the player's head
            camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);
        }

        // --- BUILDERS ---

        function buildArchitecture(m, g) {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(120, 100), m.floor);
            floor.rotation.x = -Math.PI / 2; floor.position.x = -20; floor.receiveShadow = true; scene.add(floor);
            const roof = new THREE.Mesh(new THREE.BoxGeometry(80, 1, 30), m.ceiling);
            roof.position.set(-20, 10.5, 0); roof.castShadow = true; roof.receiveShadow = true; scene.add(roof);

            createBackWindow(0, m, g); createBackWindow(-20, m, g); createBackWindow(-40, m, g);
            function createBackWindow(x, m, g) {
                const grp = new THREE.Group();
                grp.add(addMesh(new THREE.BoxGeometry(20, 2, 1), m.wall, x, 1, -10));
                grp.add(addMesh(new THREE.BoxGeometry(20, 2, 1), m.wall, x, 9, -10));
                grp.add(addMesh(new THREE.BoxGeometry(1, 10, 1), m.wall, x, 5, -10));
                grp.add(addMesh(new THREE.BoxGeometry(19, 6, 0.1), m.glass, x, 5, -10, false, false));
                scene.add(grp);
            }

            addMesh(g.box_20_10_1, m.wall, 0, 5, 10);  
            const sideWin = new THREE.Group();
            sideWin.add(addMesh(new THREE.BoxGeometry(1, 2, 20), m.wall, 10, 1, 0)); 
            sideWin.add(addMesh(new THREE.BoxGeometry(1, 2, 20), m.wall, 10, 9, 0)); 
            sideWin.add(addMesh(new THREE.BoxGeometry(1, 10, 2), m.wall, 10, 5, -9)); 
            sideWin.add(addMesh(new THREE.BoxGeometry(1, 10, 2), m.wall, 10, 5, 9));  
            sideWin.add(addMesh(new THREE.BoxGeometry(0.1, 6, 16), m.glass, 10, 5, 0, false, false));
            scene.add(sideWin);

            const div1 = new THREE.Group();
            div1.add(addMesh(new THREE.BoxGeometry(1, 3, 20), m.wall, -10, 8.5, 0)); 
            div1.add(addMesh(g.box_1_10_8, m.wall, -10, 5, -6)); 
            div1.add(addMesh(g.box_1_10_8, m.wall, -10, 5, 6));  
            scene.add(div1);

            addMesh(g.box_20_10_1, m.wall, -20, 5, 10);
            const div2 = new THREE.Group();
            div2.add(addMesh(new THREE.BoxGeometry(1, 3, 20), m.wall, -30, 8.5, 0)); 
            div2.add(addMesh(g.box_1_10_8, m.wall, -30, 5, -6)); 
            div2.add(addMesh(g.box_1_10_8, m.wall, -30, 5, 6));  
            scene.add(div2);

            addMesh(g.box_20_10_1, m.wall, -40, 5, 10);
            addMesh(g.box_1_10_20, m.wall, -50, 5, 0);   

            function addMesh(geo, mat, x, y, z, cast=true, receive=true) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                mesh.castShadow = cast; mesh.receiveShadow = receive;
                if(mesh.parent !== scene) return mesh; else scene.add(mesh);
                return mesh;
            }
        }

        function placeArt(m, g) {
            animatedObjects.art.push(createSculpture(-5, -5, new THREE.SphereGeometry(0.8, 64, 64), m.mint, 0.8));
            animatedObjects.art.push(createSculpture(0, -2, new THREE.TorusKnotGeometry(0.6, 0.2, 128, 32), m.blue, 0.8));
            animatedObjects.art.push(createSculpture(5, -6, new THREE.TorusGeometry(0.7, 0.2, 32, 100), m.mint, 0.9));
            
            createCanvas(6, 4, 0, 5, 9.4, Math.PI); 
            createCanvas(8, 3, -20, 5, 9.4, Math.PI); 
            createCanvas(2, 4, -29.4, 5, 5, Math.PI/2);
            createCanvas(3, 4, -35, 5, 9.4, Math.PI);
            createCanvas(3, 4, -45, 5, 9.4, Math.PI);
            createCanvas(8, 5, -49.4, 5, 0, Math.PI/2); 

            function createSculpture(x, z, geo, mat, yOff) {
                const ped = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1.5), m.pedestal);
                ped.position.set(x, 1, z); ped.castShadow=true; ped.receiveShadow=true; scene.add(ped);
                const art = new THREE.Mesh(geo, mat);
                art.position.set(x, 2 + yOff, z); art.castShadow=true; scene.add(art);
                return art;
            }
            function createCanvas(w, h, x, y, z, ry=0) {
                const canvas = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.15), m.canvas);
                canvas.position.set(x, y, z); canvas.rotation.y = ry; canvas.castShadow=true; scene.add(canvas);
            }
        }

        function placePlants(m, g) {
            createPlant(9, -8, 1.5); createPlant(8, 7, 1.4); 
            createPlant(-28, -8, 1.4); createPlant(-15, 7, 1.3);
            createPlant(-48, -8, 1.5); createPlant(-48, 8, 1.5);

            function createPlant(x, z, scale) {
                const group = new THREE.Group();
                const pot = new THREE.Mesh(g.pot, m.pot);
                pot.position.y = 0.4; pot.castShadow=true; pot.receiveShadow=true; group.add(pot);
                for(let i=0; i<7; i++) {
                    const stemGroup = new THREE.Group();
                    const stem = new THREE.Mesh(g.stem, m.stem); stem.castShadow=true;
                    const leaf = new THREE.Mesh(g.leaf, m.leaf); 
                    leaf.position.y = 2; leaf.rotation.x = -Math.PI/6; leaf.castShadow=true;
                    stem.add(leaf); stemGroup.add(stem);
                    stemGroup.rotation.z = 0.2 + Math.random()*0.3;
                    stemGroup.rotation.y = (i/7)*Math.PI*2 + Math.random()*0.5;
                    group.add(stemGroup);
                }
                group.position.set(x, 0, z); group.scale.setScalar(scale); 
                group.rotation.y = Math.random()*Math.PI; scene.add(group);
            }
        }

        function createCloudSea(m, g) {
            const cloudSeaGroup = new THREE.Group();
            cloudSeaGroup.position.y = -2; 
            for (let i = 0; i < 600; i++) { 
                const puff = new THREE.Mesh(g.cloudGeo, m.cloud);
                puff.position.set(
                    (Math.random() - 0.5) * 800,
                    (Math.random() * 5) - 8, 
                    (Math.random() - 0.5) * 800
                );
                const scaleXZ = 2 + Math.random() * 4;
                const scaleY = 0.5 + Math.random() * 0.5;
                puff.scale.set(scaleXZ, scaleY, scaleXZ);
                puff.rotation.y = Math.random() * Math.PI;
                puff.castShadow = true; puff.receiveShadow = true;
                cloudSeaGroup.add(puff);
            }
            scene.add(cloudSeaGroup);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            if(animatedObjects.art[0]) animatedObjects.art[0].position.y = 2.8 + Math.sin(time) * 0.1;
            if(animatedObjects.art[1]) { 
                animatedObjects.art[1].rotation.y = time * 0.2; 
                animatedObjects.art[1].rotation.x = time * 0.1; 
            }
            if(animatedObjects.art[2]) animatedObjects.art[2].rotation.y = -time * 0.1;
            
            updatePlayerMovement();

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>