<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dreamy Gallery - Smooth Nub Body</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #FFDAB9; }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-family: sans-serif; font-size: 20px;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        #instructions {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #555; font-family: sans-serif; font-size: 16px;
            background: rgba(255, 255, 255, 0.9); padding: 12px 24px; border-radius: 30px;
            pointer-events: none; opacity: 0.95; text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading">Smoothing curves...</div>
    <div id="instructions">
        <b>Click & Drag</b> to Rotate Camera &bull; <b>Scroll</b> to Zoom<br>
        <b>W A S D</b> to Move Relative to Camera &bull; <b>SHIFT</b> to Sprint
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';

        let scene, camera, renderer;
        const animatedObjects = { plants: [], art: [], clouds: [] };
        let player, keys;
        
        // --- CAMERA CONTROL VARIABLES ---
        let cameraRadius = 18;        
        let cameraAzimuth = 0; 
        let cameraElevation = 0.5;   
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        init();

        function init() {
            document.getElementById('loading').style.display = 'none';

            // --- 1. SCENE SETUP ---
            scene = new THREE.Scene();
            
            // --- PALETTE ---
            const colTop = new THREE.Color(0xAEC6CF);    
            const colMid = new THREE.Color(0xC8A2C8);    
            const colBot = new THREE.Color(0xFFDAB9);    
            
            scene.fog = new THREE.FogExp2(0xFFDAB9, 0.008); 

            // SKY SHADER
            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `;
            const fragmentShader = `
                uniform vec3 topColor;
                uniform vec3 midColor;
                uniform vec3 botColor;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize( vWorldPosition ).y;
                    vec3 color;
                    if(h < 0.1) {
                         color = mix(botColor, midColor, smoothstep(-0.1, 0.1, h));
                    } else {
                         color = mix(midColor, topColor, smoothstep(0.1, 0.7, h));
                    }
                    gl_FragColor = vec4( color, 1.0 );
                }
            `;
            const skyMat = new THREE.ShaderMaterial({
                vertexShader, fragmentShader,
                uniforms: {
                    topColor: { value: colTop },
                    midColor: { value: colMid },
                    botColor: { value: colBot }
                },
                side: THREE.BackSide
            });
            const skySphere = new THREE.Mesh(new THREE.SphereGeometry(1000, 32, 15), skyMat);
            scene.add(skySphere);

            // --- RENDERER ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; 
            renderer.setClearColor(colBot);
            document.body.appendChild(renderer.domElement);
            RectAreaLightUniformsLib.init();

            // --- CAMERA ---
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            // --- INPUT HANDLING ---
            keys = { 
                w: false, a: false, s: false, d: false, 
                up: false, down: false, left: false, right: false,
                shift: false 
            };
            
            const resetKeys = () => {
                keys.w = false; keys.a = false; keys.s = false; keys.d = false;
                keys.up = false; keys.down = false; keys.left = false; keys.right = false;
                keys.shift = false;
            };

            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = true;
                if (e.key === 'ArrowUp') keys.up = true;
                if (e.key === 'ArrowDown') keys.down = true;
                if (e.key === 'ArrowLeft') keys.left = true;
                if (e.key === 'ArrowRight') keys.right = true;
                if (e.key === 'Shift') keys.shift = true;
            });
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = false;
                if (e.key === 'ArrowUp') keys.up = false;
                if (e.key === 'ArrowDown') keys.down = false;
                if (e.key === 'ArrowLeft') keys.left = false;
                if (e.key === 'ArrowRight') keys.right = false;
                if (e.key === 'Shift') keys.shift = false;
            });
            
            window.addEventListener('blur', resetKeys);
            window.addEventListener('visibilitychange', () => {
                if (document.hidden) resetKeys();
            });

            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
            window.addEventListener('mouseup', () => { isDragging = false; });
            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaX = e.offsetX - previousMousePosition.x;
                const deltaY = e.offsetY - previousMousePosition.y;
                const sensitivity = 0.005;
                cameraAzimuth -= deltaX * sensitivity;
                cameraElevation -= deltaY * sensitivity;
                cameraElevation = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraElevation));
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
            window.addEventListener('wheel', (e) => {
                const zoomSpeed = 0.5;
                if (e.deltaY > 0) cameraRadius += zoomSpeed;
                else cameraRadius -= zoomSpeed;
                cameraRadius = Math.max(3, Math.min(30, cameraRadius));
            });

            // --- 2. LIGHTING ---
            const hemiLight = new THREE.HemisphereLight(colMid, colBot, 0.6);
            scene.add(hemiLight);

            const sunLight = new THREE.DirectionalLight(0xFFF5E1, 1.2); 
            sunLight.position.set(50, 40, -50); 
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(4096, 4096); 
            scene.add(sunLight);

            createWindowLight(0, -20);
            createWindowLight(-20, -20);
            createWallLight(-40, -19); 
            createWindowLight(10, 0, Math.PI/2); 

            function createWindowLight(x, z, ry=0) {
                const rectLight = new THREE.RectAreaLight(0xFFE4C4, 3.0, 18, 10);
                rectLight.position.set(x, 5, z);
                rectLight.rotation.y = ry;
                if(ry === 0) rectLight.lookAt(x, 5, z + 20); 
                scene.add(rectLight);
            }
            function createWallLight(x, z) {
                const rectLight = new THREE.RectAreaLight(0xFFF0E0, 2.0, 18, 10);
                rectLight.position.set(x, 5, z);
                rectLight.lookAt(x, 5, z + 20); 
                scene.add(rectLight);
            }

            // --- 3. MATERIALS & TEXTURES ---
            function createNoiseTexture(baseColorHex, noiseIntensity = 20, scale = 1) {
                const size = 512;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                const c = new THREE.Color(baseColorHex);
                ctx.fillStyle = `rgb(${c.r * 255}, ${c.g * 255}, ${c.b * 255})`;
                ctx.fillRect(0, 0, size, size);
                const imgData = ctx.getImageData(0, 0, size, size);
                const data = imgData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const noise = (Math.random() - 0.5) * noiseIntensity;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));
                    data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
                    data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
                }
                ctx.putImageData(imgData, 0, 0);
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(scale, scale);
                return texture;
            }

            const colBeigePlant = 0xDEC4A6;
            const feltTexture = createNoiseTexture(colBeigePlant, 40, 1);
            const concreteTexture = createNoiseTexture(0xA9A9A9, 50, 4);
            const canvasTexture = createNoiseTexture(0xffffff, 15, 1);
            const sculptureFeltTex = createNoiseTexture(0xAAAAAA, 120, 4); 

            const mats = {
                wall: new THREE.MeshStandardMaterial({ color: 0xFFD1DC, roughness: 0.5 }), 
                ceiling: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 }), 
                glass: new THREE.MeshPhysicalMaterial({ roughness: 0, transmission: 1, thickness: 0.5, ior: 1.5, transparent: true }),
                floor: new THREE.MeshStandardMaterial({ map: concreteTexture, roughness: 0.9, bumpMap: concreteTexture, bumpScale: 0.05 }), 
                pedestal: new THREE.MeshStandardMaterial({ color: 0xfffdf0, roughness: 0.5 }),
                canvas: new THREE.MeshStandardMaterial({ map: canvasTexture, roughness: 0.8 }),
                pot: new THREE.MeshStandardMaterial({ map: feltTexture, roughness: 1.0, bumpMap: feltTexture, bumpScale: 0.02 }),
                leaf: new THREE.MeshStandardMaterial({ map: feltTexture, roughness: 1.0, bumpMap: feltTexture, bumpScale: 0.05, side: THREE.DoubleSide }),
                stem: new THREE.MeshStandardMaterial({ map: feltTexture, roughness: 1.0, bumpMap: feltTexture, bumpScale: 0.02 }),
                cloud: new THREE.MeshStandardMaterial({ color: 0xFFE5B4, roughness: 0.9, emissive: 0xFFC0CB, emissiveIntensity: 0.1, transparent: true, opacity: 0.9, flatShading: true }),
                
                // Shiny Bright White Plastic
                playerBody: new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF, 
                    roughness: 0.05, 
                    metalness: 0.0 
                }),
                playerVisor: new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.1, metalness: 0.1 }),
                playerEye: new THREE.MeshStandardMaterial({ color: 0x00FFFF, emissive: 0x00FFFF, emissiveIntensity: 2.0 }),
                playerBlush: new THREE.MeshStandardMaterial({ color: 0xFF69B4, roughness: 1.0, transparent: true, opacity: 0.6 }),
                
                sculptureFeltTex: sculptureFeltTex
            };

            const geos = {
                pot: new THREE.CylinderGeometry(0.4, 0.35, 0.8, 32),
                stem: new THREE.CylinderGeometry(0.05, 0.04, 2, 8).translate(0, 1, 0),
                leaf: new THREE.CircleGeometry(0.5, 32).scale(0.5, 2.5, 1).translate(0, 1.25, 0), 
                cloudGeo: new THREE.SphereGeometry(5, 16, 12),
                wall_standard: new THREE.BoxGeometry(20, 10, 0.2),
                wall_divider: new THREE.BoxGeometry(0.2, 10, 16), 
                wall_side: new THREE.BoxGeometry(0.2, 10, 40)
            };

            // --- 4. BUILD SCENE ---
            buildArchitecture(mats, geos);
            placeArt(mats, geos);
            placePlants(mats, geos);
            createCloudSea(mats, geos); 
            createPlayer(mats);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createPlayer(m) {
            player = new THREE.Group();
            
            // 1. Robot Body (UPDATED: Smooth Curve using Lathe)
            // Creating a spline curve to get the perfect "nub" shape
            const points = [];
            // Bottom tip (0,0) -> Nub curve -> Widest point -> Neck
            const curve = new THREE.SplineCurve([
                new THREE.Vector2(0.0, 0.0),    // Tip
                new THREE.Vector2(0.15, 0.08),  // Nub curve start
                new THREE.Vector2(0.30, 0.25),  // Lower body
                new THREE.Vector2(0.42, 0.55),  // Widest part (shoulders)
                new THREE.Vector2(0.35, 0.70)   // Neck connection
            ]);
            
            // Get points from curve for LatheGeometry
            const pathPoints = curve.getPoints(16); 
            const bodyGeo = new THREE.LatheGeometry(pathPoints, 32);
            
            const body = new THREE.Mesh(bodyGeo, m.playerBody);
            body.position.y = 0.45; // Adjust vertical position to align with head
            body.castShadow = true;
            player.add(body);

            // 2. Robot Head
            const headGeo = new THREE.SphereGeometry(0.5, 32, 32);
            const head = new THREE.Mesh(headGeo, m.playerBody);
            head.position.y = 1.45; 
            head.castShadow = true;
            player.add(head);

            // 3. Visor (Flush)
            const visorGeo = new THREE.CapsuleGeometry(0.28, 0.45, 4, 16);
            const visor = new THREE.Mesh(visorGeo, m.playerVisor);
            visor.rotation.z = Math.PI / 2; 
            visor.scale.set(1, 1, 0.5); 
            visor.position.set(0, 0, 0.38); 
            head.add(visor);

            // 4. Glowing Eyes (Flush)
            const eyeGeo = new THREE.CapsuleGeometry(0.08, 0.12, 4, 8);
            
            const eyeL = new THREE.Mesh(eyeGeo, m.playerEye);
            eyeL.scale.set(1, 1, 0.2); 
            eyeL.position.set(-0.18, 0.05, 0.53); 
            eyeL.rotation.z = 0.1; 
            head.add(eyeL);

            const eyeR = new THREE.Mesh(eyeGeo, m.playerEye);
            eyeR.scale.set(1, 1, 0.2); 
            eyeR.position.set(0.18, 0.05, 0.53);
            eyeR.rotation.z = -0.1; 
            head.add(eyeR);

            // 5. Antenna
            const stalkGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 8);
            const stalk = new THREE.Mesh(stalkGeo, m.playerBody);
            stalk.position.y = 0.6; 
            head.add(stalk);

            const ballGeo = new THREE.SphereGeometry(0.06, 12, 12);
            const ball = new THREE.Mesh(ballGeo, m.playerBody);
            ball.position.y = 0.15; 
            stalk.add(ball);

            // 6. Flap Arms
            const armGeo = new THREE.CapsuleGeometry(0.12, 0.25, 4, 8);
            
            const armL = new THREE.Mesh(armGeo, m.playerBody);
            armL.position.set(-0.40, 0.8, 0); 
            armL.rotation.z = 0.2; 
            armL.scale.set(1, 1, 0.3); 
            armL.castShadow = true;
            player.add(armL);

            const armR = new THREE.Mesh(armGeo, m.playerBody);
            armR.position.set(0.40, 0.8, 0); 
            armR.rotation.z = -0.2; 
            armR.scale.set(1, 1, 0.3); 
            armR.castShadow = true;
            player.add(armR);

            player.position.set(5, 0, 5);
            player.rotation.y = Math.PI; 
            
            scene.add(player);
        }

        // --- MOVEMENT LOGIC ---
        function updatePlayerMovement() {
            if(!player) return;

            if (!document.hasFocus()) {
                keys.w = false; keys.a = false; keys.s = false; keys.d = false;
                keys.up = false; keys.down = false; keys.left = false; keys.right = false;
            }

            const moveSpeed = keys.shift ? 0.35 : 0.15; 
            
            const inputVector = new THREE.Vector3(0, 0, 0);
            if (keys.w || keys.up) inputVector.z -= 1; 
            if (keys.s || keys.down) inputVector.z += 1; 
            if (keys.a || keys.left) inputVector.x -= 1; 
            if (keys.d || keys.right) inputVector.x += 1; 

            if (inputVector.lengthSq() > 0) {
                inputVector.normalize();

                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                camDir.y = 0; 
                camDir.normalize();

                const camRight = new THREE.Vector3();
                camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0));

                const moveVec = new THREE.Vector3();
                moveVec.addScaledVector(camDir, -inputVector.z);
                moveVec.addScaledVector(camRight, inputVector.x);
                
                moveVec.normalize().multiplyScalar(moveSpeed);

                player.position.add(moveVec);

                const targetRotation = Math.atan2(moveVec.x, moveVec.z);
                const targetQuat = new THREE.Quaternion();
                targetQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetRotation);
                player.quaternion.slerp(targetQuat, 0.15); 
            }

            // --- COLLISION ---
            if (player.position.z < -18.5) player.position.z = -18.5;
            if (player.position.z > 18.5) player.position.z = 18.5;
            if (player.position.x > 8.5) player.position.x = 8.5;
            if (player.position.x < -48.5) player.position.x = -48.5;

            // --- CAMERA FOLLOW ---
            const x = cameraRadius * Math.sin(cameraElevation) * Math.sin(cameraAzimuth);
            const y = cameraRadius * Math.cos(cameraElevation);
            const z = cameraRadius * Math.sin(cameraElevation) * Math.cos(cameraAzimuth);

            const targetX = player.position.x + x;
            const targetY = (player.position.y + 1.5) + y;
            const targetZ = player.position.z + z;

            camera.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 0.1);
            camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);
        }

        // --- BUILDERS ---

        function buildArchitecture(m, g) {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(120, 60), m.floor);
            floor.rotation.x = -Math.PI / 2; 
            floor.position.set(-20, 0, 0); 
            floor.receiveShadow = true; scene.add(floor);

            const roof = new THREE.Mesh(new THREE.BoxGeometry(80, 0.2, 40), m.ceiling);
            roof.position.set(-20, 10.1, 0); 
            roof.castShadow = true; 
            roof.receiveShadow = true; 
            scene.add(roof);

            createBackWindow(0, m, g); 
            createBackWindow(-20, m, g); 
            
            const r3Back = new THREE.Mesh(g.wall_standard, m.wall);
            r3Back.position.set(-40, 5, -20);
            r3Back.receiveShadow = true; scene.add(r3Back);

            function createBackWindow(x, m, g) {
                const grp = new THREE.Group();
                grp.add(createMesh(new THREE.BoxGeometry(20, 2, 0.2), m.wall, x, 1, -20));
                grp.add(createMesh(new THREE.BoxGeometry(20, 2, 0.2), m.wall, x, 9, -20));
                grp.add(createMesh(new THREE.BoxGeometry(0.2, 10, 0.2), m.wall, x, 5, -20));
                grp.add(createMesh(new THREE.BoxGeometry(19, 6, 0.1), m.glass, x, 5, -20, false, false));
                scene.add(grp);
            }

            const sideWin = new THREE.Group();
            sideWin.add(createMesh(new THREE.BoxGeometry(0.2, 2, 40), m.wall, 10, 1, 0)); 
            sideWin.add(createMesh(new THREE.BoxGeometry(0.2, 2, 40), m.wall, 10, 9, 0)); 
            sideWin.add(createMesh(new THREE.BoxGeometry(0.2, 10, 2), m.wall, 10, 5, -19)); 
            sideWin.add(createMesh(new THREE.BoxGeometry(0.2, 10, 2), m.wall, 10, 5, 19));  
            sideWin.add(createMesh(new THREE.BoxGeometry(0.1, 6, 36), m.glass, 10, 5, 0, false, false));
            scene.add(sideWin);

            const div1 = new THREE.Group();
            div1.add(createMesh(new THREE.BoxGeometry(0.2, 3, 40), m.wall, -10, 8.5, 0)); 
            div1.add(createMesh(g.wall_divider, m.wall, -10, 5, -12)); 
            div1.add(createMesh(g.wall_divider, m.wall, -10, 5, 12));  
            scene.add(div1);

            const div2 = new THREE.Group();
            div2.add(createMesh(new THREE.BoxGeometry(0.2, 3, 40), m.wall, -30, 8.5, 0)); 
            div2.add(createMesh(g.wall_divider, m.wall, -30, 5, -12)); 
            div2.add(createMesh(g.wall_divider, m.wall, -30, 5, 12));  
            scene.add(div2);

            const r3Side = new THREE.Mesh(g.wall_side, m.wall);
            r3Side.position.set(-50, 5, 0);
            r3Side.receiveShadow = true; scene.add(r3Side);

            function createMesh(geo, mat, x, y, z, cast=true, receive=true) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                mesh.castShadow = cast; mesh.receiveShadow = receive;
                return mesh;
            }
        }

        function placeArt(m, g) {
            const paletteColors = [
                0x00A8E8, // Bright Blue
                0xFF5A6E, // Salmon Pink
                0x8DE3B8, // Mint Green
                0xFFBE61, // Orange
                0xFA8EC1  // Bubblegum Pink
            ];

            const scMats = paletteColors.map(color => new THREE.MeshStandardMaterial({
                color: color,
                roughness: 1.0,
                metalness: 0.0,
                bumpMap: m.sculptureFeltTex,
                bumpScale: 0.08
            }));

            animatedObjects.art.push(createSculpture(-5, -5, new THREE.SphereGeometry(0.8, 64, 64), scMats[0], 0.8));
            animatedObjects.art.push(createSculpture(0, -2, new THREE.TorusKnotGeometry(0.6, 0.2, 128, 32), scMats[1], 0.8));
            animatedObjects.art.push(createSculpture(5, -6, new THREE.TorusGeometry(0.7, 0.2, 32, 100), scMats[2], 0.9));
            animatedObjects.art.push(createSculpture(-20, 8, new THREE.DodecahedronGeometry(0.7), scMats[3], 0.8));
            animatedObjects.art.push(createSculpture(-20, -8, new THREE.OctahedronGeometry(0.7), scMats[4], 0.8));
            animatedObjects.art.push(createSculpture(-40, 8, new THREE.TorusGeometry(0.5, 0.15, 16, 50), scMats[0], 0.8));
            animatedObjects.art.push(createSculpture(-40, -8, new THREE.ConeGeometry(0.7, 1.5, 4), scMats[1], 0.9));

            createCanvas(1.5, 3, 9.4, 5, 19, -Math.PI/2);
            createCanvas(1.5, 3, 9.4, 5, -19, -Math.PI/2);
            createCanvas(2, 3, -9.4, 6.5, -12, Math.PI/2); 
            createCanvas(2, 2, -9.4, 3, -12, Math.PI/2);
            createCanvas(2, 4, -9.4, 5, 12, Math.PI/2);
            createCanvas(2, 2, -9.4, 2, 16, Math.PI/2);
            createCanvas(2, 2, -9.4, 8, 16, Math.PI/2);
            createCanvas(1.5, 1.5, -9.4, 8, -8, Math.PI/2);
            createCanvas(1.5, 1.5, -9.4, 5, -8, Math.PI/2);
            createCanvas(1.5, 1.5, -9.4, 2, -8, Math.PI/2);

            createCanvas(6, 6, -10.6, 5, 8, -Math.PI/2); 
            createCanvas(3, 4, -10.6, 5, 13.5, -Math.PI/2); 
            
            createCanvas(1.5, 1.5, -10.6, 8.5, 16, -Math.PI/2);
            createCanvas(1.5, 1.5, -10.6, 6.5, 16, -Math.PI/2);
            createCanvas(1.5, 1.5, -10.6, 4.5, 16, -Math.PI/2);
            createCanvas(1.5, 1.5, -10.6, 2.5, 16, -Math.PI/2);

            createCanvas(3, 4, -10.6, 5, -12, -Math.PI/2);
            createCanvas(6, 6, -10.6, 5, -9, -Math.PI/2); 
            createCanvas(2, 2, -10.6, 8, -16, -Math.PI/2);
            createCanvas(2, 2, -10.6, 5, -16, -Math.PI/2);
            createCanvas(2, 2, -10.6, 2, -16, -Math.PI/2);

            createCanvas(5, 7, -29.4, 5, 9, Math.PI/2); 
            createCanvas(2, 2, -29.4, 8, 14, Math.PI/2);
            createCanvas(2, 2, -29.4, 5, 14, Math.PI/2);
            createCanvas(2, 2, -29.4, 2, 14, Math.PI/2);
            createCanvas(2, 4, -29.4, 5, 17, Math.PI/2);

            createCanvas(5, 7, -29.4, 5, -9, Math.PI/2); 
            createCanvas(1.5, 4, -29.4, 5, -16, Math.PI/2); 
            createCanvas(1, 1, -29.4, 8, -16, Math.PI/2);
            createCanvas(1, 1, -29.4, 2, -16, Math.PI/2);
            createCanvas(2, 3, -29.4, 5, -13, Math.PI/2);

            createCanvas(4, 3, -30.6, 5, 10, -Math.PI/2);
            createCanvas(1.5, 2, -30.6, 7.5, 15, -Math.PI/2);
            createCanvas(1.5, 2, -30.6, 2.5, 15, -Math.PI/2);
            createCanvas(4, 3, -30.6, 5, -10, -Math.PI/2);
            createCanvas(1.5, 5, -30.6, 5, -16, -Math.PI/2);

            createCanvas(6, 4, -49.4, 5, 0, Math.PI/2); 
            createCanvas(6, 2, -49.4, 8.5, 0, Math.PI/2); 
            createCanvas(6, 1.5, -49.4, 1.5, 0, Math.PI/2); 
            createCanvas(3, 8, -49.4, 5, -6, Math.PI/2); 
            createCanvas(2, 2, -49.4, 8, -10, Math.PI/2);
            createCanvas(2, 2, -49.4, 5, -10, Math.PI/2);
            createCanvas(2, 2, -49.4, 2, -10, Math.PI/2);
            createCanvas(4, 3, -49.4, 7, -15, Math.PI/2);
            createCanvas(4, 3, -49.4, 2.5, -15, Math.PI/2);
            createCanvas(3, 8, -49.4, 5, 6, Math.PI/2); 
            createCanvas(2, 2, -49.4, 8, 10, Math.PI/2);
            createCanvas(2, 2, -49.4, 5, 10, Math.PI/2);
            createCanvas(2, 2, -49.4, 2, 10, Math.PI/2);
            createCanvas(4, 3, -49.4, 7, 15, Math.PI/2);
            createCanvas(4, 3, -49.4, 2.5, 15, Math.PI/2);
            createCanvas(6, 4, -40, 5, -19.4, 0); 
            createCanvas(2, 2, -34, 5, -19.4, 0);
            createCanvas(2, 2, -46, 5, -19.4, 0);
            createCanvas(2, 2, -34, 8, -19.4, 0);
            createCanvas(2, 2, -46, 8, -19.4, 0);

            function createSculpture(x, z, geo, mat, yOff) {
                const ped = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1.5), m.pedestal);
                ped.position.set(x, 1, z); ped.castShadow=true; ped.receiveShadow=true; scene.add(ped);
                const art = new THREE.Mesh(geo, mat);
                art.userData = { baseY: 2 + yOff };
                art.position.set(x, 2 + yOff, z); art.castShadow=true; scene.add(art);
                return art;
            }
            function createCanvas(w, h, x, y, z, ry=0) {
                const canvas = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.15), m.canvas);
                canvas.position.set(x, y, z); canvas.rotation.y = ry; canvas.castShadow=true; scene.add(canvas);
            }
        }

        function placePlants(m, g) {
            createPlant(8, 10, 1.4);  
            createPlant(8, 0, 1.3);   
            createPlant(5, -18, 1.5); 
            createPlant(-15, -15, 1.4);
            createPlant(-20, -15, 1.6);
            createPlant(-25, -15, 1.4);
            createPlant(-45, -10, 1.5);
            createPlant(-45, 0, 1.4);
            createPlant(-45, 10, 1.5);

            function createPlant(x, z, scale) {
                const group = new THREE.Group();
                const pot = new THREE.Mesh(g.pot, m.pot);
                pot.position.y = 0.4; pot.castShadow=true; pot.receiveShadow=true; group.add(pot);
                for(let i=0; i<7; i++) {
                    const stemGroup = new THREE.Group();
                    const stem = new THREE.Mesh(g.stem, m.stem); stem.castShadow=true;
                    const leaf = new THREE.Mesh(g.leaf, m.leaf); 
                    leaf.position.y = 2; leaf.rotation.x = -Math.PI/6; leaf.castShadow=true;
                    stem.add(leaf); stemGroup.add(stem);
                    stemGroup.rotation.z = 0.2 + Math.random()*0.3;
                    stemGroup.rotation.y = (i/7)*Math.PI*2 + Math.random()*0.5;
                    group.add(stemGroup);
                }
                group.position.set(x, 0, z); group.scale.setScalar(scale); 
                group.rotation.y = Math.random()*Math.PI; scene.add(group);
            }
        }

        function createCloudSea(m, g) {
            const cloudSeaGroup = new THREE.Group();
            cloudSeaGroup.position.y = -12; 
            for (let i = 0; i < 600; i++) { 
                const puff = new THREE.Mesh(g.cloudGeo, m.cloud);
                puff.position.set(
                    (Math.random() - 0.5) * 800,
                    (Math.random() * 5) - 8, 
                    (Math.random() - 0.5) * 800
                );
                const scaleXZ = 2 + Math.random() * 4;
                const scaleY = 0.5 + Math.random() * 0.5;
                puff.scale.set(scaleXZ, scaleY, scaleXZ);
                puff.rotation.y = Math.random() * Math.PI;
                puff.castShadow = true; puff.receiveShadow = true;
                cloudSeaGroup.add(puff);
            }
            scene.add(cloudSeaGroup);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            animatedObjects.art.forEach((obj, i) => {
                const base = obj.userData.baseY || 2; 
                obj.position.y = base + Math.sin(time + i) * 0.1;
                const dir = (i % 2 === 0) ? 1 : -1;
                obj.rotation.y = time * 0.2 * dir;
                obj.rotation.x = time * 0.05 * dir;
            });
            
            updatePlayerMovement();

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>