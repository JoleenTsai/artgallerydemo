<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dreamy Gallery - New Sculptures</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #FFDAB9; }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-family: sans-serif; font-size: 20px;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        #instructions {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #777; font-family: sans-serif; font-size: 16px;
            background: rgba(255, 255, 255, 0.9); padding: 10px 20px; border-radius: 20px;
            pointer-events: none; opacity: 0.9; text-align: center;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading">Sculpting new forms...</div>
    <div id="instructions">
        <b>Click & Drag</b> to Rotate Camera<br>
        <b>W A S D</b> to Walk &bull; <b>SHIFT</b> to Run &bull; <b>Scroll</b> to Zoom
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';

        let scene, camera, renderer;
        const animatedObjects = { plants: [], art: [], clouds: [] };
        let player, keys;
        
        // --- CAMERA CONTROL VARIABLES ---
        let cameraRadius = 18;        
        let cameraAzimuth = 0; 
        let cameraElevation = 0.5;   
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        init();

        function init() {
            document.getElementById('loading').style.display = 'none';

            // --- 1. SCENE SETUP ---
            scene = new THREE.Scene();
            
            // --- PALETTE ---
            const colTop = new THREE.Color(0xAEC6CF);    
            const colMid = new THREE.Color(0xC8A2C8);    
            const colBot = new THREE.Color(0xFFDAB9);    
            
            scene.fog = new THREE.FogExp2(0xFFDAB9, 0.008);

            // SKY SHADER
            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `;
            const fragmentShader = `
                uniform vec3 topColor;
                uniform vec3 midColor;
                uniform vec3 botColor;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize( vWorldPosition ).y;
                    vec3 color;
                    if(h < 0.1) {
                         color = mix(botColor, midColor, smoothstep(-0.1, 0.1, h));
                    } else {
                         color = mix(midColor, topColor, smoothstep(0.1, 0.7, h));
                    }
                    gl_FragColor = vec4( color, 1.0 );
                }
            `;
            const skyMat = new THREE.ShaderMaterial({
                vertexShader, fragmentShader,
                uniforms: {
                    topColor: { value: colTop },
                    midColor: { value: colMid },
                    botColor: { value: colBot }
                },
                side: THREE.BackSide
            });
            const skySphere = new THREE.Mesh(new THREE.SphereGeometry(1000, 32, 15), skyMat);
            scene.add(skySphere);

            // --- RENDERER ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; 
            renderer.setClearColor(colBot);
            document.body.appendChild(renderer.domElement);
            RectAreaLightUniformsLib.init();

            // --- CAMERA ---
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            // --- INPUT HANDLING ---
            keys = { w: false, a: false, s: false, d: false, shift: false };
            
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = true;
                if (e.key === 'ArrowUp') keys.w = true;
                if (e.key === 'ArrowDown') keys.s = true;
                if (e.key === 'ArrowLeft') keys.a = true;
                if (e.key === 'ArrowRight') keys.d = true;
                if (e.key === 'Shift') keys.shift = true;
            });
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = false;
                if (e.key === 'ArrowUp') keys.w = false;
                if (e.key === 'ArrowDown') keys.s = false;
                if (e.key === 'ArrowLeft') keys.a = false;
                if (e.key === 'ArrowRight') keys.d = false;
                if (e.key === 'Shift') keys.shift = false;
            });

            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
            window.addEventListener('mouseup', () => { isDragging = false; });
            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaX = e.offsetX - previousMousePosition.x;
                const deltaY = e.offsetY - previousMousePosition.y;
                const sensitivity = 0.005;
                cameraAzimuth -= deltaX * sensitivity;
                cameraElevation -= deltaY * sensitivity;
                cameraElevation = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraElevation));
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
            window.addEventListener('wheel', (e) => {
                const zoomSpeed = 0.5;
                if (e.deltaY > 0) cameraRadius += zoomSpeed;
                else cameraRadius -= zoomSpeed;
                cameraRadius = Math.max(3, Math.min(30, cameraRadius));
            });

            // --- 2. LIGHTING ---
            const hemiLight = new THREE.HemisphereLight(colMid, colBot, 0.6);
            scene.add(hemiLight);

            const sunLight = new THREE.DirectionalLight(0xFFF5E1, 1.2); 
            sunLight.position.set(50, 40, -50); 
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(4096, 4096); 
            scene.add(sunLight);

            createWindowLight(0, -20);
            createWindowLight(-20, -20);
            createWallLight(-40, -19); 
            createWindowLight(10, 0, Math.PI/2); 

            function createWindowLight(x, z, ry=0) {
                const rectLight = new THREE.RectAreaLight(0xFFE4C4, 3.0, 18, 10);
                rectLight.position.set(x, 5, z);
                rectLight.rotation.y = ry;
                if(ry === 0) rectLight.lookAt(x, 5, z + 20); 
                scene.add(rectLight);
            }
            function createWallLight(x, z) {
                const rectLight = new THREE.RectAreaLight(0xFFF0E0, 2.0, 18, 10);
                rectLight.position.set(x, 5, z);
                rectLight.lookAt(x, 5, z + 20); 
                scene.add(rectLight);
            }

            // --- 3. MATERIALS ---
            const colPlantUnified = 0xDEC4A6;

            const mats = {
                wall: new THREE.MeshStandardMaterial({ color: 0xFFD1DC, roughness: 0.5 }), 
                ceiling: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 }), 
                glass: new THREE.MeshPhysicalMaterial({ roughness: 0, transmission: 1, thickness: 0.5, ior: 1.5, transparent: true }),
                floor: new THREE.MeshStandardMaterial({ color: 0xfff8e7, roughness: 0.6 }), 
                mint: new THREE.MeshStandardMaterial({ color: 0xb2e0d6, roughness: 0.3 }),
                blue: new THREE.MeshStandardMaterial({ color: 0xaec6cf, roughness: 0.3 }),
                pedestal: new THREE.MeshStandardMaterial({ color: 0xfffdf0, roughness: 0.5 }),
                canvas: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 }),
                pot: new THREE.MeshStandardMaterial({ color: colPlantUnified, roughness: 0.9 }),
                leaf: new THREE.MeshStandardMaterial({ color: colPlantUnified, roughness: 0.8, side: THREE.DoubleSide }),
                stem: new THREE.MeshStandardMaterial({ color: colPlantUnified, roughness: 0.8 }),
                cloud: new THREE.MeshStandardMaterial({ 
                    color: 0xFFE5B4,      
                    roughness: 0.9, 
                    emissive: 0xFFC0CB,   
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.9,
                    flatShading: true
                }),
                playerBody: new THREE.MeshStandardMaterial({ color: 0xe6e6fa, roughness: 0.3 }),
                playerEye: new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.1 })
            };

            const geos = {
                pot: new THREE.CylinderGeometry(0.4, 0.35, 0.8, 32),
                stem: new THREE.CylinderGeometry(0.05, 0.04, 2, 8).translate(0, 1, 0),
                leaf: new THREE.CircleGeometry(0.5, 16).scale(0.5, 2.5, 1).translate(0, 1.25, 0),
                cloudGeo: new THREE.SphereGeometry(5, 16, 12),
                wall_standard: new THREE.BoxGeometry(20, 10, 0.2),
                wall_divider: new THREE.BoxGeometry(0.2, 10, 16), 
                wall_side: new THREE.BoxGeometry(0.2, 10, 40) 
            };

            // --- 4. BUILD SCENE ---
            buildArchitecture(mats, geos);
            placeArt(mats, geos);
            placePlants(mats, geos);
            createCloudSea(mats, geos); 
            createPlayer(mats);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createPlayer(m) {
            player = new THREE.Group();
            
            const bodyGeo = new THREE.CapsuleGeometry(0.4, 0.8, 4, 8);
            const body = new THREE.Mesh(bodyGeo, m.playerBody);
            body.position.y = 0.8; 
            body.castShadow = true;
            player.add(body);

            const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
            const head = new THREE.Mesh(headGeo, m.playerBody);
            head.position.y = 1.4;
            head.castShadow = true;
            player.add(head);

            const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeL = new THREE.Mesh(eyeGeo, m.playerEye);
            eyeL.position.set(-0.15, 1.45, 0.28);
            player.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, m.playerEye);
            eyeR.position.set(0.15, 1.45, 0.28);
            player.add(eyeR);

            player.position.set(5, 0, 5);
            player.rotation.y = Math.PI; 
            
            scene.add(player);
        }

        function updatePlayerMovement() {
            if(!player) return;

            const moveSpeed = keys.shift ? 0.30 : 0.15; 
            const rotSpeed = 0.04;

            if (keys.w) player.translateZ(moveSpeed); 
            if (keys.s) player.translateZ(-moveSpeed); 
            if (keys.a) player.rotation.y += rotSpeed; 
            if (keys.d) player.rotation.y -= rotSpeed; 

            if (player.position.z < -18.5) player.position.z = -18.5;
            if (player.position.z > 18.5) player.position.z = 18.5;
            if (player.position.x > 8.5) player.position.x = 8.5;
            if (player.position.x < -48.5) player.position.x = -48.5;

            const x = cameraRadius * Math.sin(cameraElevation) * Math.sin(cameraAzimuth);
            const y = cameraRadius * Math.cos(cameraElevation);
            const z = cameraRadius * Math.sin(cameraElevation) * Math.cos(cameraAzimuth);

            const targetX = player.position.x + x;
            const targetY = (player.position.y + 1.5) + y;
            const targetZ = player.position.z + z;

            camera.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 0.1);
            camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);
        }

        // --- BUILDERS ---

        function buildArchitecture(m, g) {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(120, 60), m.floor);
            floor.rotation.x = -Math.PI / 2; 
            floor.position.set(-20, 0, 0); 
            floor.receiveShadow = true; scene.add(floor);

            const roof = new THREE.Mesh(new THREE.BoxGeometry(80, 0.2, 40), m.ceiling);
            roof.position.set(-20, 10.1, 0); roof.castShadow = true; roof.receiveShadow = true; scene.add(roof);

            createBackWindow(0, m, g); 
            createBackWindow(-20, m, g); 
            
            const r3Back = new THREE.Mesh(g.wall_standard, m.wall);
            r3Back.position.set(-40, 5, -20);
            r3Back.receiveShadow = true; scene.add(r3Back);

            function createBackWindow(x, m, g) {
                const grp = new THREE.Group();
                grp.add(createMesh(new THREE.BoxGeometry(20, 2, 0.2), m.wall, x, 1, -20));
                grp.add(createMesh(new THREE.BoxGeometry(20, 2, 0.2), m.wall, x, 9, -20));
                grp.add(createMesh(new THREE.BoxGeometry(0.2, 10, 0.2), m.wall, x, 5, -20));
                grp.add(createMesh(new THREE.BoxGeometry(19, 6, 0.1), m.glass, x, 5, -20, false, false));
                scene.add(grp);
            }

            const sideWin = new THREE.Group();
            sideWin.add(createMesh(new THREE.BoxGeometry(0.2, 2, 40), m.wall, 10, 1, 0)); 
            sideWin.add(createMesh(new THREE.BoxGeometry(0.2, 2, 40), m.wall, 10, 9, 0)); 
            sideWin.add(createMesh(new THREE.BoxGeometry(0.2, 10, 2), m.wall, 10, 5, -19)); 
            sideWin.add(createMesh(new THREE.BoxGeometry(0.2, 10, 2), m.wall, 10, 5, 19));  
            sideWin.add(createMesh(new THREE.BoxGeometry(0.1, 6, 36), m.glass, 10, 5, 0, false, false));
            scene.add(sideWin);

            const div1 = new THREE.Group();
            div1.add(createMesh(new THREE.BoxGeometry(0.2, 3, 40), m.wall, -10, 8.5, 0)); 
            div1.add(createMesh(g.wall_divider, m.wall, -10, 5, -12)); 
            div1.add(createMesh(g.wall_divider, m.wall, -10, 5, 12));  
            scene.add(div1);

            const div2 = new THREE.Group();
            div2.add(createMesh(new THREE.BoxGeometry(0.2, 3, 40), m.wall, -30, 8.5, 0)); 
            div2.add(createMesh(g.wall_divider, m.wall, -30, 5, -12)); 
            div2.add(createMesh(g.wall_divider, m.wall, -30, 5, 12));  
            scene.add(div2);

            const r3Side = new THREE.Mesh(g.wall_side, m.wall);
            r3Side.position.set(-50, 5, 0);
            r3Side.receiveShadow = true; scene.add(r3Side);

            function createMesh(geo, mat, x, y, z, cast=true, receive=true) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                mesh.castShadow = cast; mesh.receiveShadow = receive;
                return mesh;
            }
        }

        function placeArt(m, g) {
            // --- ROOM 1 SCULPTURES (Existing) ---
            animatedObjects.art.push(createSculpture(-5, -5, new THREE.SphereGeometry(0.8, 64, 64), m.mint, 0.8));
            animatedObjects.art.push(createSculpture(0, -2, new THREE.TorusKnotGeometry(0.6, 0.2, 128, 32), m.blue, 0.8));
            animatedObjects.art.push(createSculpture(5, -6, new THREE.TorusGeometry(0.7, 0.2, 32, 100), m.mint, 0.9));
            
            // --- ROOM 2 SCULPTURES (New) ---
            // Left: Dodecahedron
            animatedObjects.art.push(createSculpture(-20, 8, new THREE.DodecahedronGeometry(0.7), m.mint, 0.8));
            // Right: Octahedron
            animatedObjects.art.push(createSculpture(-20, -8, new THREE.OctahedronGeometry(0.7), m.blue, 0.8));

            // --- ROOM 3 SCULPTURES (New) ---
            // Left: Spire (Torus Stack)
            const spireGeo = new THREE.CylinderGeometry(0.2, 0.2, 2, 8); // Simple stick placeholder for complex shape, or just use Cone
            animatedObjects.art.push(createSculpture(-40, 8, new THREE.TorusGeometry(0.5, 0.15, 16, 50), m.mint, 0.8));
            // Right: Pyramid (Cone 4 sides)
            animatedObjects.art.push(createSculpture(-40, -8, new THREE.ConeGeometry(0.7, 1.5, 4), m.blue, 0.9));

            // --- CANVAS ARRANGEMENT ---
            
            // Room 1 Side Art
            createCanvas(1.5, 3, 9.4, 5, 19, -Math.PI/2);
            createCanvas(1.5, 3, 9.4, 5, -19, -Math.PI/2);
            createCanvas(2, 3, -9.4, 6.5, -12, Math.PI/2); 
            createCanvas(2, 2, -9.4, 3, -12, Math.PI/2);
            createCanvas(2, 4, -9.4, 5, 12, Math.PI/2);
            createCanvas(2, 2, -9.4, 2, 16, Math.PI/2);
            createCanvas(2, 2, -9.4, 8, 16, Math.PI/2);
            createCanvas(1.5, 1.5, -9.4, 8, -8, Math.PI/2);
            createCanvas(1.5, 1.5, -9.4, 5, -8, Math.PI/2);
            createCanvas(1.5, 1.5, -9.4, 2, -8, Math.PI/2);

            // Room 2 (Middle)
            createCanvas(3, 4, -10.6, 5, -12, -Math.PI/2);
            createCanvas(3, 4, -10.6, 5, 12, -Math.PI/2);
            createCanvas(6, 6, -10.6, 5, -9, -Math.PI/2); 
            createCanvas(6, 6, -10.6, 5, 9, -Math.PI/2);  

            createCanvas(5, 7, -29.4, 5, -9, Math.PI/2); 
            createCanvas(5, 7, -29.4, 5, 9, Math.PI/2);  
            createCanvas(1.5, 4, -29.4, 5, -16, Math.PI/2); 
            createCanvas(1, 1, -29.4, 8, -16, Math.PI/2);

            // Room 3 (End)
            createCanvas(4, 3, -30.6, 5, 10, -Math.PI/2);
            createCanvas(1.5, 2, -30.6, 7.5, 15, -Math.PI/2);
            createCanvas(1.5, 2, -30.6, 2.5, 15, -Math.PI/2);
            createCanvas(4, 3, -30.6, 5, -10, -Math.PI/2);
            createCanvas(1.5, 5, -30.6, 5, -16, -Math.PI/2);

            createCanvas(6, 4, -49.4, 5, 0, Math.PI/2); 
            createCanvas(6, 2, -49.4, 8.5, 0, Math.PI/2); 
            createCanvas(6, 1.5, -49.4, 1.5, 0, Math.PI/2); 

            createCanvas(3, 8, -49.4, 5, -6, Math.PI/2); 
            createCanvas(2, 2, -49.4, 8, -10, Math.PI/2);
            createCanvas(2, 2, -49.4, 5, -10, Math.PI/2);
            createCanvas(2, 2, -49.4, 2, -10, Math.PI/2);
            
            createCanvas(4, 3, -49.4, 7, -15, Math.PI/2);
            createCanvas(4, 3, -49.4, 2.5, -15, Math.PI/2);

            createCanvas(3, 8, -49.4, 5, 6, Math.PI/2); 
            createCanvas(2, 2, -49.4, 8, 10, Math.PI/2);
            createCanvas(2, 2, -49.4, 5, 10, Math.PI/2);
            createCanvas(2, 2, -49.4, 2, 10, Math.PI/2);

            createCanvas(4, 3, -49.4, 7, 15, Math.PI/2);
            createCanvas(4, 3, -49.4, 2.5, 15, Math.PI/2);

            createCanvas(6, 4, -40, 5, -19.4, 0); 
            createCanvas(2, 2, -34, 5, -19.4, 0);
            createCanvas(2, 2, -46, 5, -19.4, 0);
            createCanvas(2, 2, -34, 8, -19.4, 0);
            createCanvas(2, 2, -46, 8, -19.4, 0);

            function createSculpture(x, z, geo, mat, yOff) {
                const ped = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1.5), m.pedestal);
                ped.position.set(x, 1, z); ped.castShadow=true; ped.receiveShadow=true; scene.add(ped);
                const art = new THREE.Mesh(geo, mat);
                // Save initial Y so we can animate around it
                art.userData = { baseY: 2 + yOff };
                art.position.set(x, 2 + yOff, z); art.castShadow=true; scene.add(art);
                return art;
            }
            function createCanvas(w, h, x, y, z, ry=0) {
                const canvas = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.15), m.canvas);
                canvas.position.set(x, y, z); canvas.rotation.y = ry; canvas.castShadow=true; scene.add(canvas);
            }
        }

        function placePlants(m, g) {
            createPlant(8, 10, 1.4);  
            createPlant(8, 0, 1.3);   
            createPlant(5, -18, 1.5); 

            createPlant(-15, -18, 1.4);
            createPlant(-20, -18, 1.6);
            createPlant(-25, -18, 1.4);

            createPlant(-48, -10, 1.5);
            createPlant(-48, 0, 1.4);
            createPlant(-48, 10, 1.5);

            function createPlant(x, z, scale) {
                const group = new THREE.Group();
                const pot = new THREE.Mesh(g.pot, m.pot);
                pot.position.y = 0.4; pot.castShadow=true; pot.receiveShadow=true; group.add(pot);
                for(let i=0; i<7; i++) {
                    const stemGroup = new THREE.Group();
                    const stem = new THREE.Mesh(g.stem, m.stem); stem.castShadow=true;
                    const leaf = new THREE.Mesh(g.leaf, m.leaf); 
                    leaf.position.y = 2; leaf.rotation.x = -Math.PI/6; leaf.castShadow=true;
                    stem.add(leaf); stemGroup.add(stem);
                    stemGroup.rotation.z = 0.2 + Math.random()*0.3;
                    stemGroup.rotation.y = (i/7)*Math.PI*2 + Math.random()*0.5;
                    group.add(stemGroup);
                }
                group.position.set(x, 0, z); group.scale.setScalar(scale); 
                group.rotation.y = Math.random()*Math.PI; scene.add(group);
            }
        }

        function createCloudSea(m, g) {
            const cloudSeaGroup = new THREE.Group();
            cloudSeaGroup.position.y = -12; 
            for (let i = 0; i < 600; i++) { 
                const puff = new THREE.Mesh(g.cloudGeo, m.cloud);
                puff.position.set(
                    (Math.random() - 0.5) * 800,
                    (Math.random() * 5) - 8, 
                    (Math.random() - 0.5) * 800
                );
                const scaleXZ = 2 + Math.random() * 4;
                const scaleY = 0.5 + Math.random() * 0.5;
                puff.scale.set(scaleXZ, scaleY, scaleXZ);
                puff.rotation.y = Math.random() * Math.PI;
                puff.castShadow = true; puff.receiveShadow = true;
                cloudSeaGroup.add(puff);
            }
            scene.add(cloudSeaGroup);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            // Generic animation for all art pieces
            animatedObjects.art.forEach((obj, i) => {
                // Bobbing
                const base = obj.userData.baseY || 2; 
                obj.position.y = base + Math.sin(time + i) * 0.1;
                // Rotating
                const dir = (i % 2 === 0) ? 1 : -1;
                obj.rotation.y = time * 0.2 * dir;
                obj.rotation.x = time * 0.05 * dir;
            });
            
            updatePlayerMovement();

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>